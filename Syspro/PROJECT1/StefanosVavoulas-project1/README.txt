Στέφανος Βάβουλας - ΕΡΓΑΣΙΑ 1

Η εργασία περιέχει:
-Απλό Makefile με δυνατοτητες make, make clean
-virusesFile.txt, countriesFile.txt, firstNames.txt, lastNames.txt αρχεία με δεδομένα που χρησιμοποιούνται για δημιουργία inputFile
-testFile.sh bash που δημιουργεί το inputFile.txt με τα παραπάνω αρχεία
-Αρχεία κώδικα για την εφαρμογή: main.cpp, citizen.cpp/h, BloomFilter.cpp/h SkipList.cpp/h date.cpp/h

Εντολές εκτέλεσης:
Για εκτέλεση του bash script/δημιουργία inputFile(Προφανώς ο αριθμός numLines μπορεί να είναι στο [1-10000] και το duplicatesAllowed 0):
>./testFile.sh virusesFile.txt countriesFile.txt 5000 1
>make
>./vaccineMonitor -c inputFile -b 100    -ή-     ./vaccineMonitor -b 100 -c inputFile

Προφανώς ο αριθμός numLines μπορεί να είναι στο [1-10000] και το duplicatesAllowed 0. Επίσης το bloomSize δίνεται σε KBytes,
οπότε με είσοδο 100(KBytes) όπως εδώ, ο πίνακας κάθε bloomfilter θα έχει 800,000 bits.
Η εργασία έχει ελεγχθεί για σωστή λειτουργία στα linux της σχολής μέσω putty, όπου και παρατηρήθηκε αρκετή καθυστέρηση στην δημιουργία του
inputFile από το bash script (ενδεικτικά ~κοντά σε λεπτό για 5k εγγραφές)

--> 25%: bash script
Όσον αφορά το bash script: Φτιάχνει 4 πίνακες, 1 για κάθε ένα από τα αρχεία virusesFile.txt, countriesFile.txt, firstNames.txt, lastNames.txt.
-Όταν τα duplicates είναι ενεργοποιημένα, τότε μπαίνει σε επανάληψη όπου κάθε φορά τοποθετεί στο inputFile ένα τυχαίο ID από 0-9999. Με βάση το ID
τοποθετούνται ΣΥΓΚΕΚΡΙΜΕΝΑ fname,lname,country,age, ΑΛΛΑ ΤΥΧΑΙΑ virus, vaccinated, dateVaccinated. Επομένως ενδέχεται στην εκτέλεση η εφαρμογή να 
βρίσκει errors σε εγγραφές που έχουν ίδια fname,lname,country,age,virus αλλά θα είναι σχετικά σπάνιο. Δεν έχω προσθέσει τη δυνατότητα να έχουν τα
ίδια IDs διαφορετικά fname,lname,country,age καθώς δεν τα χρειαζόμουν για το debugging, παρ'ολαυτα η εφαρμογή ελέγχει και την ύπαρξη αυτών και 
παρουσιάζει errors για όλες τις προβληματικές εγγραφές που ζητήθηκαν στην εκφώνηση.
-Όταν τα duplicates είναι απενεργοποιημένα, τοποθετώ σε ένα πίνακα με numLines θέσεις τους αριθμούς από 0-numLines και κάνω τον πίνακα shuffle.
Στη συνέχεια, διασχίζω τον πίνακα με τη σειρά και τοποθετώ στο inputFile το εκάστοτε ID με τυχαία traits.
Τυχόν λεπτομέρειες για την υλοποίηση αναφέρονται στα σχόλια του κώδικα.

--> 75%: vaccineMonitor
Όσον αφορά το vaccineMonitor, έχω χωρίσει τη main σε 3 parts: 
----- PART 1: GET INPUT FROM COMMAND LINE (INPUT FILE NAME, BLOOM SIZE) AND SAVE IT -----
Απλός έλεγχος των command line arguments, μετατροπή του bloomSize σε bytes

---- PART 2: PARSE THE INPUT FILE - SAVE THE RECORDS' DATA IN OUR OWN DATA STRUCTURES ---
Δημιουργώ λίστες για countries, citizens, BloomFilters, vaccinatedSkipLists, nonVaccinatedSkipLists.
Στη συνέχεια ανοίγω και διαβάζω το αρχείο (inputFile) γραμμή προς γραμμή, και δημιουργώ citizen object που αρχικοποιείται με τα στοιχεία της 
γραμμής. Ελέγχω αν είναι consistent οι εγγραφές (από άποψη σύνταξης, σωστού αριθμού χαρακτηριστικών κλπ - βλ. citizen constructor, αλλά και από
άποψη inconsistency σε σχέση με άλλη ήδη περασμένη εγγραφή σύμφωνα με τα ζητούμενα της εργασίας - βλ. συνάρτηση consistent στο αρχείο citizen.cpp)
Ακολουθεί προαιρετική εκτύπωση των δομών που δημιουργήθηκαν (μάλιστα, στη συνάρτηση void SLL::print() στο SkipList.cpp υπάρχει προαιρετική
εκτύπωση κάθε SkipList ανά επίπεδο, οπότε με αφαίρεση των σχολίων φαίνεται ότι έχουν γίνει σωστά οι αρχικοποιήσεις των SkipLists κατά την εκτέλεση)

--------------- PART 3: GET INPUT FROM USER AND PERFORM EACH COMMAND --------------------
Τρέχει επανάληψη στην οποία ο χρήστης μπορεί να εισάγει εντολή η οποία αν έχει γραφεί διαφορετικά και έχει το σωστό αριθμό ορισμάτων, εκτελείται.
Διαφορετικά εκτυπώνεται ERROR: INVALID COMMAND και ο χρήστης μπορεί να δοκιμάσει ξανά. Η επανάληψη τελειώνει με την εντολή /exit και στη συνέχεια
διαγράφονται όλες οι δομές και ελευθερώνεται ο χώρος (δοκιμασμένο με valgrind στο linux28 της σχολής).
Τυχόν λεπτομέρειες για την υλοποίηση αναφέρονται στα σχόλια του κώδικα.

Τέλος, σχετικά με τις υλοποιήσεις μου:
--> dates.cpp/h: Έχει συνάρτηση που ελέγχει αν ένα string έχει τη μορφή date και συνάρτηση που ελέγχει αν μια ημερομηνία είναι ανάμεσα σε δύο άλλες
(η σύγκριση για το τελευταίο γίνεται μετατρέποντας τα string dates σε πίνακες με 3 στοιχεία: μέρα, μήνα, έτος

--> citizen.cpp/h: Έχει τον citizen constructor που δημιουργεί citizen με βάση κάθε record του inputFile και ελέγχει για inconsistencies.
Έχει λίστα με pointers σε citizen objects (προς αποφυγή duplication) στην οποία προστίθεται κάθε νέος citizen και η οποία χρειάζεται για ελέγχους
για inconsistency.
Έχει τη συνάρτηση consistent που ελέγχει inconsistency σε σχέση με άλλη ήδη περασμένη εγγραφή.
Έχει λίστα με χώρες που χρησιμοποιείται στις εντολές /populationStatus, /popStatusByAge για να εκτυπωθούν τα ποσοστά ανά χώρα

--> BloomFilter.cpp/h: Σύμφωνα με τα ζητούμενα της εργασίας αρχικοποιώ K=16, M=bloomSize(100kbytes με είσοδο 100).
Δημιουργώ έναν bool array (αρχικοποιημένο με 0) για το bloomFilter κάθε ιού και αλλάζω με κάθε νέα εγγραφή το index hash_i % M του array σε 1.
Στον έλεγχο επιστρέφει MAYBE αν τα indexes για το συγκεκριμένο ID είναι 1, και NOT VACCINATED αν έστω 1 από αυτά είναι 0.
Τέλος, έχω μία λίστα στην οποία αποθηκεύω όλα τα bloomFilters ανά virus, η οποία και εκτυπώνεται στην εκτέλεση.

--> SkipList.cpp/h: Σχετικά με την υλοποίηση του SkipList, δημιούργησα SkipNodes όπου ο καθένας κρατάει pointer σε citizen object, key(ID του citizen)
και έναν πίνακα forward που κρατάει με τη σειρά του pointers σε nodes διαφορετικών επιπέδων της SkipList. Συγκεκριμένα ένα Node επιπέδου L κρατάει
L pointers από 0 έως L. Σαφώς, με τη δημιουργία πίνακα περιορίζω τον αριθμό των levels σε συγκεκριμένο αριθμό, παρ'ολαυτα, για τα δεδομένα της άσκησης
(μέχρι 10k εγγραφές), δίνοντας στον πίνακα μέγιστο ύψος logN όπου N = 10k, μπορώ με σιγουριά να βάλω μέγιστο ύψος 10 που έτσι κι αλλιώς θα ήταν
το μέγιστο ύψος που θα προσέφερε complexity αναζήτησης O(log n).
Σύμφωνα με αυτή την υλοποίηση έχω δημιουργήσει και τις συναρτήσεις insert, remove, check καθώς και μερικές ακόμα που χρησιμοποιούνται για εκτέλεση
εντολών από τον χρήστη. Έχω αναλυτικά σχόλια για το τι κάνει η κάθε συνάρτηση στον κωδικά μου, αλλά θα εξηγήσω ενδεικτικά και την insert που είναι
η πιο βασική:
Ξεκινώντας από το υψηλότερο επίπεδο της δεδομένης SkipList, προχωράμε δεξιά εάν το key(ID) του στοιχείου που εισάγουμε (ας το πουμε keyInsert)
είναι μεγαλύτερο από κλειδί του επόμενου (δεξιού) στοιχείου από αυτό που είμαστε. Διαφορετικά αν το επόμενο key είναι μικρότερο από το keyInsert
ή δεν υπάρχει επόμενο στοιχείο σε αυτό το επίπεδο, πηγαίνουμε κάτω (δηλαδή στο ίδιο στοιχείο αλλά στο επόμενο επίπεδο).
Τελικά, όταν φτάνουμε στο επίπεδο 0 γνωρίζουμε πλέον με σιγουριά ότι πρέπει να εισάγουμε το στοιχείο στη θέση δεξιά από τη θέση όπου βρισκόμαστε.
Αν σε αυτή τη θέση δεν υπάρχει στοιχείο, ή το key(ID) του  node είναι διαφορετικό από το keyInsert, βρίσκουμε ένα τυχαίο επίπεδο (0-10) για το
νέο node που θα προσθέσουμε, και ξεκινώντας από το χαμηλότερο επίπεδο τοποθετούμε στην θέση που βρήκαμε το νέο node με κλειδί keyInsert, αλλάζοντας
τον forward pointer του προηγούμενου node σε κάθε επίπεδο να δείχνουν σε αυτό, και το forward pointer του ίδιου να δείχνει στο επόμενο node 
(που ήταν προηγουμένως εκεί που έδειχνε το ο forward pointer του προηγούμενου node).
Με αντίστοιχη λογική εκτελούνται οι remove, check, print.

Τέλος, έχω δημιουργήσει λίστα με SkipLists (όπως αναφέρθηκε στη main δημιουργούνται δύο τέτοιες λίστες: vaccinatedSLL, nonVaccinatedSLL) η οποία
διαθέτει και τις κατάλληλες συναρτήσεις που ζητούνται για να εκτελεστεί κάθε εντολή του χρήστη.
Τυχόν λεπτομέρειες για την υλοποίηση των συναρτήσεων της SkipList αλλά και της SkipListsList(SLL) αναφέρονται στα σχόλια του κώδικα και θεωρώ 
υπερβολικό να αναλύσω τη λειτουργία τους.

